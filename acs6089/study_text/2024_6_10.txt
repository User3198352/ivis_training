6월 10일 월요일


d. Threads - Introduction to concurrency

Interleaving
인터리빙이란 멀티쓰레드 환경에서 여러 쓰레드의 명령이 서로 번갈아가며 실행되는 방식을 의미한다. 주로 운영체제가 순서와 실행하는 시간을 결정하기에 사용자 입장에서는 각 쓰레드의 명령이 일정 순서 없이 섞여 실행되는 것처럼 보인다. 사용자 입장에서는 각 쓰레드가 어떻게 인터리빙 될지 모르기 때문에 여러 쓰레드가 같은 주소에 있는 값을 동시에 접근, 사용할 때 의도한대로 작동하지 않을 수 있고 이러한 의도하지 않는 결과는 주로 경쟁 상태과 같은 동기화 문제가 원인이다.

Race Condition
경쟁 상태는 여러 쓰레드 또는 프로세스가 공유 자원에 동시에 접근할 때, 실행 순서에 따라 결과가 달라지는 현상이다. 자원에 대한 접근이 원자적이지 않아서 여러 단계의 연산이 중간에 다른 쓰레드에 의해서도 경쟁 상태가 발생할 수 있다. 이를 해결하기 위해서는 공유 자원에 대한 쓰레드의 접근을 제어하는 여러 동기화 기법을 사용해야한다. 다양한 동기화 기법은 Threads synchronization & communication에서 설명한다.

Concurrency is Hard to Test and Debug
동시성 문제에 의해 발생한 버그나 경쟁 조건을 발견하고 테스트 및 디버그 하는 것은 매우 어렵다. 왜냐하면 각 쓰레드를 제어하는 것이 유저가 아니라 운영체제가 실행 중인 다른 프로그램, 네트워크 상태, 컴퓨터 내부의 자원의 상태 등 다양한 변수 및 환경에 의해 자동으로 인터리빙하기 때문에 경쟁 상태가 발생하는 부분이 예측 불가능하며 일정하게 나타나는 것도 아니기 때문이다.

STL Thread
C++에서 쓰레드를 사용하고 싶으면 STL에서 제공하는 thread 라이브러리를 추가하여 사용하면 된다. 사용시에는 std::thread thObj(<CALLBACK>);와 같이 사용하며 CALLBACK 부분에는 함수 포인터나 함수 객체, 람다 함수 등 쓰레드 내부에서 수행할 부분을 넣어 주면된다. 새로운 쓰레드는 생성과 동시에 시행되며 하나의 프로그램에서 여러 쓰레드가 실행 중일때 해당 쓰레드가 끝난 후에 메인을 닫고 싶으면 join() 함수를 사용한다.

POSIX Thread
C++에서 제공하는 쓰레드 말고도 POSIX에서 정의한 쓰레드를 기반으로 만든 쓰레드를 사용하고 싶으면 pthread 라이브러리를 추가하여 사용하면 된다. int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);와 같이 선언하면 바로 pthread_t *thread 부분의 쓰레드 객체가 생성되어 쓰레드에서 원하는 작업을 수행한다. pthread_attr_t *attr의 attr에는 해당 쓰레드의 속성을 넣어 준다. void *(*start_routine)(void *)에는 실제 쓰레드 내에서 작동할 함수를 넣어 해당 쓰레드가 수행한다. void *arg부분은 쓰레드에서 수행할 함수에 전파할 여러 변수를 넣어준다.




d. Thread - Threads synchronization & communication

Introduction to concurrency에서 설명하였듯이 공유 자원에 여러 쓰레드들이 동시에 접근하게 되면 경쟁 상태 문제가 발생한다고 하였다. 이번 장에서는 이러한 경쟁 생태 문제를 제어할 수 있는 여러 동기화 기법에 대해 설명한다.

critical sections
임계 구역이란 여러 쓰레드가 동시에 접근해서는 안 되는 공유 자원에 접근하는 코드 영역을 의미한다. 이런 공유 자원에 접근하는 임계 구역을 적절하게 관리하지 않으면 
경쟁 상태 등의 문제가 발생한다. 따라서 임계 구역에는 한 번에 하나의 쓰레드만 접근할 수 있도록 동기화 메커니즘을 잘 구성해야한다.

mutex
뮤텍스는 상호배제를 제공하여 여러 쓰레드가 하나의 공유 자원에 접근할 때 하나의 쓰레드에 독점적으로 한 공유 자원에 접근할 권한을 주고(lock) 나머지 쓰레드는 점유중인 쓰레드의 작업이 끝날 때까지 대기하는 방식이다. 따라서 뮤텍스는 여러 쓰레드들이 순차적으로 한 공유 자원을 독점적으로 사용하는 방식으로 데이터 일관성을 유지한다. 

semaphore
세마포어는 뮤텍스와 다르게 특정 개수만큼의 리소스에 대해 공유 자원 접근을 허용하며 P함수(wait, acquire)과 V함수(signal, release)을 통해 제어한다. 여러 쓰레드가 공유 자원이 존재하는 임계 영역을 사용할 때, 해당 공유 자원을 사용하고자 하는  쓰레드는 P함수를 사용하여 세마포어 카운터를 감소 시키고 해당 공유 자원을 다 사용하였다면 V함수를 통해 세마포어 카운터를 증가 시킨다. 세마포어 카운터 값이 0보다 작거나 같으면 더 이상 쓰레드의 접근을 허용하지 않으며 접근하지 못한 쓰레드는 대기 시킨다. 세마포어 카운터의 값의 범위에 따라 0과 1만을 값을 가지는 이진 세마포어와 임의의 양의 정수 값을 가지는 카운팅 세마포어로 나뉜다. 이진 세마포어의 경우 하나의 쓰레드만 임계 영역에 접근하기 때문에 뮤텍스와 유사하게 작동한다. 반면 카운팅 세마포어는 초기에 설정한 양의 정수 값 만큼의 쓰레드 접근을 허용하나 이럴 경우 2개 이상의 프로세스가 동시에 임계 구역에 들어갈 수 있으므로 상호 배제를 보장할 수 없게 된다.

condition variables
조건 변수는 특정 조건이 만족될 때까지 쓰레드를 대기 상태로 두고 조건이 만족되면 대기 중인 쓰레드를 깨워서 실행할 수 있게 해주는 동기화 도구이다. 조건 변수는 뮤텍스와 함께 사용되며 일반적으로 생산자 소비자 문제에서 생산자가 소비자가 할 작업들을 다 수행할때까지 소비자를 대기 상태로 두었다가 생산자의 작업을 다 수행하면 소비자를 깨워 작업을 진행시키는 방식으로 사용한다. 

spinlock
스핀락은 잠금을 획득하려는 쓰레드가 반복적으로 잠금 상태를 확인하며, 짧은 임계 구역에서 사용될 때 효과적이다. 스핀락은 문맥 전환이 없어서 대기 시간이 매우 짧으나 계속해서 잠금 상태를 확인하기에 CPU 자원을 지속적으로 소비한다. 따라서 만약 대기 시간이 길다면 계속 자원을 소비하는 스핀락보단 뮤텍스가 효율적이고 잘 못 사용하면 여러 쓰레드가 자원을 무한히 기다리는 교착 상태에 빠질 수 도 있다.
